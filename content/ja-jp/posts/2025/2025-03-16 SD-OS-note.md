---
slug: 242
title: 'ソフトウェア設計技術者 - OS分野のノート'
# draft: true
author: yexca
date: '2025-03-16T19:35:38+09:00'
categories:
    - 資格勉強
tags:
    - ソフトウェア設計技術者
    - オペレーティングシステム
---

{{< notice >}} この記事は ChatGPT によって翻訳されました {{< /notice >}}

ファイル作成時間を見ると試験後っぽいので、おそらく移動したときに「書こう」って思っただけかもしれない。

## OSの位置づけ

コンピュータシステムはハードウェアとソフトウェアの2つの構成要素からなる。  
ソフトウェアがインストールされていないコンピュータは「ベアマシン」と呼ばれていて、それを直接使うのは不便で、効率も悪い。

オペレーティングシステム（OS）は、人と機械のギャップを埋めるためのソフトウェアで、ユーザーとコンピュータのインターフェース的な存在。

OSの位置づけは下図のとおり：

![计算机系统层次结构图](https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/04-操作系统/计算机系统层次结构图.17vkqmgvzpfg.webp)

図からもわかるように、OS はベアマシン上の最初のソフトで、ハードウェア機能を最初に拡張する存在。他のすべてのソフト（編集、アセンブラ、コンパイラ、DB管理など）やアプリケーションは OS の上に成り立ってる。

ユーザーから見ても、OS があれば直接ハードをいじらずに済むし、OS 経由でコマンドやサービスを使って操作できる。だから OS はユーザーとコンピュータの間の重要な橋渡し役になってる。

## プロセス管理

プロセス管理（＝プロセッサ管理）は、複数のプログラムが同時に実行される環境（多重プログラミング、タイムシェアリングなど）で、各プログラムの動的な状態を「プロセス」として扱う。  
プロセスは「リソースを持ち独立して動ける単位」で、同時実行や協調動作・競合の制御が必要になる。

### 順次実行の特徴

前順関係を示すグラフ（有向非巡回グラフ）で、ノードは処理単位、矢印は順番の関係を表す。  
たとえば Pi→Pj なら「Pi が終わらないと Pj は実行できない」。

次の図では、入力→計算→出力の順番関係：

![3-个结点的前趋图](https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/04-操作系统/3-个结点的前趋图.3xixrma8r6w0.webp)

順次実行の特徴は、以下の3つ：

- 順序性  
- 閉鎖性（外部の影響なしに動く）  
- 再現性（毎回同じ結果）

### 同時実行の特徴

多重プログラムを導入すると、プログラムは並列に実行されることになる。  
前順関係のない処理は、CPU・I/O に並行して割り当てできる。

たとえば CPU、入力デバイス、出力デバイスが1つずつあるときの例：

![程序并发执行](https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/04-操作系统/程序并发执行.443cloyuv8g0.webp)

このときの特徴は以下：

1. 閉鎖性がなくなる  
2. 実行順が固定でなくなる  
3. プロセス間の制約が発生する（干渉・協調）

### プロセス状態と状態遷移

#### 三態モデル

基本的な3つの状態：

| 状態 | CPU  | リソース |
| :--: | :--: | :------: |
| 実行 | 〇   | 〇       |
| 準備 | ×    | 〇       |
| 待機 | ×    | ×       |

![进程的三态模型](https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/04-操作系统/进程的三态模型.6r4viz6q16w0.webp)

#### 五態モデル

現実のシステムでは「新規作成」「終了待ち」も加わる：

![进程的五态模型](https://cdn.jsdelivr.net/gh/yexca/picx-images-hosting@master/2023/04-操作系统/进程的五态模型.17ia7e0v3zc0.webp)

## プロセス間通信

複数のプロセスが同時に動くと、リソースの共有や協調作業が必要になる。  
このときの情報のやりとりが「プロセス間通信」。

**同期（synchronization）**：協調に必要な直接的な制御  
**排他（mutual exclusion）**：リソースをめぐる間接的な制御

### 同期

たとえば A がバッファにデータを書いて、それを B が読む場合、A が終わらないと B は動けない。

つまり「同期」とは、協調動作を行うプロセス同士のタイミング合わせのこと。

### 排他

同時に1つしか使えないリソース（＝クリティカルリソース）を複数のプロセスが取り合うこと。

たとえばプリンタ、共有変数など。

### クリティカルセクションの管理ルール

1. 空いてたら入る  
2. 他が使ってたら待つ  
3. 必ず順番が回ってくる  
4. 待ち続けず、CPU を手放す

### セマフォ（信号量）

Dijkstra が提唱した手法。  
以下2つの型がある：

- 公共セマフォ（初期値 1）：排他制御  
- 私用セマフォ（初期値 0）：同期制御

#### P/V操作

```c++
Procedure P(Var S:Semaphore);
Begin
    S := S - 1;
    If S < 0 then W(S) {待機キューに追加}
End;

Procedure V(Var S:Semaphore);
Begin
    S := S + 1;
    If S <= 0 then R(S) {待機から起こす}
End;
~~~

### 排他制御の例

```c++
if 車が通ったら then
    begin
        P(mutex)
        COUNT := COUNT + 1;
        V(mutex)
    end
GOTO L1;

begin
    P(mutex)
    PRINT COUNT;
    COUNT := 0;
    V(mutex)
end
GOTO L2;
```

▶ 詳しくは：[【操作系统】进程间通信—互斥](https://www.bilibili.com/video/BV1oK4y1n7xH)

### 同期制御の例

典型例：単一バッファの producer/consumer 問題。
 セマフォの値 0 → データなし、1 → データあり。

▶ 詳しくは：[【操作系统】进程间通信—同步](https://www.bilibili.com/video/BV1Pz4y1m7Hy)

### デッドロック（死锁）

例：リソース m＝5、プロセス数 n＝3、各プロセスは k＝3 個必要
 → m＜nk ならデッドロックになる可能性あり

**回避条件**：m ≥ n×(k-1)

### デッドロックの対策

- 放置（見なかったフリ）
- 予防（4条件の破壊）
  - 静的割当：最初に全部渡す（効率悪い）
  - 順序割当：リソースに優先順をつける
- 回避：状態を常にチェック（代表：銀行家のアルゴリズム）

▶ 銀行家算法：[動画リンク](https://www.bilibili.com/video/BV18X4y1u7aU/?p=4)

## スレッド

プロセスは「リソース単位」であり、「スケジューリング単位」でもあるけど、
 これだと切り替えコストが高くなる。
 そこで、「リソース＝プロセス」「スケジューリング＝スレッド」と分けた。

スレッドは「軽量プロセス」とも呼ばれて、同じプロセス内のスレッド同士はメモリ空間などを共有できる。

つまり：

- スレッド切り替えは軽い
- 複数タスクを高速に動かせる
- リソースはプロセス単位で保持される
